package openpme.cpp.textGen;

/*Generated by MPS */

import jetbrains.mps.text.rt.TextGenAspectBase;
import openpme.cpp.structure.LanguageConceptSwitch;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.text.rt.TextGenDescriptor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.text.rt.TextGenModelOutline;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TextGenAspectDescriptor extends TextGenAspectBase {
  private final LanguageConceptSwitch myIndex = new LanguageConceptSwitch();

  public TextGenAspectDescriptor() {
  }

  @Nullable
  @Override
  public TextGenDescriptor getDescriptor(@NotNull SAbstractConcept concept) {
    switch (myIndex.index(concept)) {
      case LanguageConceptSwitch.AddressOfExpression:
        return new AddressOfExpression_TextGen();
      case LanguageConceptSwitch.ArrayDeclaration:
        return new ArrayDeclaration_TextGen();
      case LanguageConceptSwitch.ArrayLiteral:
        return new ArrayLiteral_TextGen();
      case LanguageConceptSwitch.ArrayParameterDeclaration:
        return new ArrayParameterDeclaration_TextGen();
      case LanguageConceptSwitch.ArrayTemplate:
        return new ArrayTemplate_TextGen();
      case LanguageConceptSwitch.AutoType:
        return new AutoType_TextGen();
      case LanguageConceptSwitch.BaseAssignmentExpression:
        return new BaseAssignmentExpression_TextGen();
      case LanguageConceptSwitch.BoundaryPPME:
        return new BoundaryPPME_TextGen();
      case LanguageConceptSwitch.CharType:
        return new CharType_TextGen();
      case LanguageConceptSwitch.ClassInstanceDecl:
        return new ClassInstanceDecl_TextGen();
      case LanguageConceptSwitch.ClassInstanceReference:
        return new ClassInstanceReference_TextGen();
      case LanguageConceptSwitch.ConstexprDeclaration:
        return new ConstexprDeclaration_TextGen();
      case LanguageConceptSwitch.Continue:
        return new Continue_TextGen();
      case LanguageConceptSwitch.DecimalLiteral:
        return new DecimalLiteral_TextGen();
      case LanguageConceptSwitch.DivExpression:
        return new DivExpression_TextGen();
      case LanguageConceptSwitch.DotCall:
        return new DotCall_TextGen();
      case LanguageConceptSwitch.DoubleLiteral:
        return new DoubleLiteral_TextGen();
      case LanguageConceptSwitch.DoubleType:
        return new DoubleType_TextGen();
      case LanguageConceptSwitch.EqualsExpression:
        return new EqualsExpression_TextGen();
      case LanguageConceptSwitch.ExpressionPPME:
        return new ExpressionPPME_TextGen();
      case LanguageConceptSwitch.ExpressionStatement:
        return new ExpressionStatement_TextGen();
      case LanguageConceptSwitch.File:
        return new File_TextGen();
      case LanguageConceptSwitch.FloatLiteral:
        return new FloatLiteral_TextGen();
      case LanguageConceptSwitch.FloatType:
        return new FloatType_TextGen();
      case LanguageConceptSwitch.GreaterThanExpression:
        return new GreaterThanExpression_TextGen();
      case LanguageConceptSwitch.IfStatement:
        return new IfStatement_TextGen();
      case LanguageConceptSwitch.Include:
        return new Include_TextGen();
      case LanguageConceptSwitch.IndexedExpression:
        return new IndexedExpression_TextGen();
      case LanguageConceptSwitch.IntegerLiteral:
        return new IntegerLiteral_TextGen();
      case LanguageConceptSwitch.IntegerType:
        return new IntegerType_TextGen();
      case LanguageConceptSwitch.MethodDeclaration:
        return new MethodDeclaration_TextGen();
      case LanguageConceptSwitch.MinusExpression:
        return new MinusExpression_TextGen();
      case LanguageConceptSwitch.MulExpression:
        return new MulExpression_TextGen();
      case LanguageConceptSwitch.NewParagraph:
        return new NewParagraph_TextGen();
      case LanguageConceptSwitch.Package:
        return new Package_TextGen();
      case LanguageConceptSwitch.ParameterDeclaration:
        return new ParameterDeclaration_TextGen();
      case LanguageConceptSwitch.ParenthesizedExpression:
        return new ParenthesizedExpression_TextGen();
      case LanguageConceptSwitch.PlusExpression:
        return new PlusExpression_TextGen();
      case LanguageConceptSwitch.PointerType:
        return new PointerType_TextGen();
      case LanguageConceptSwitch.PostIncrement:
        return new PostIncrement_TextGen();
      case LanguageConceptSwitch.PowerExpression:
        return new PowerExpression_TextGen();
      case LanguageConceptSwitch.PreProcessorExpression:
        return new PreProcessorExpression_TextGen();
      case LanguageConceptSwitch.SizeType:
        return new SizeType_TextGen();
      case LanguageConceptSwitch.StatementList:
        return new StatementList_TextGen();
      case LanguageConceptSwitch.StringLiteral:
        return new StringLiteral_TextGen();
      case LanguageConceptSwitch.Template:
        return new Template_TextGen();
      case LanguageConceptSwitch.TemplateTypename:
        return new TemplateTypename_TextGen();
      case LanguageConceptSwitch.Type:
        return new Type_TextGen();
      case LanguageConceptSwitch.UncheckedReference:
        return new UncheckedReference_TextGen();
      case LanguageConceptSwitch.UnkownClassType:
        return new UnkownClassType_TextGen();
      case LanguageConceptSwitch.UnkownMethodCall:
        return new UnkownMethodCall_TextGen();
      case LanguageConceptSwitch.VariableDeclaration:
        return new VariableDeclaration_TextGen();
      case LanguageConceptSwitch.VariableReference:
        return new VariableReference_TextGen();
      case LanguageConceptSwitch.VoidType:
        return new VoidType_TextGen();
      case LanguageConceptSwitch.WhileLoop:
        return new WhileLoop_TextGen();
    }
    return null;
  }

  @Override
  public void breakdownToUnits(@NotNull TextGenModelOutline outline) {
    for (SNode root : outline.getModel().getRootNodes()) {
      if (root.getConcept().equals(CONCEPTS.File$Kx)) {
        String fname = getFileName_File(root);
        String ext = getFileExtension_File(root);
        outline.registerTextUnit((ext == null ? fname : (fname + '.' + ext)), root);
        continue;
      }
    }
  }
  private static String getFileName_File(SNode node) {
    return "file";
  }
  private static String getFileExtension_File(SNode node) {
    return "cpp";
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept File$Kx = MetaAdapterFactory.getConcept(0x6ebd153bbe954d8bL, 0xa7f3f07bf7fb7d8fL, 0x2822197bc696c681L, "openpme.cpp.structure.File");
  }
}
